<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Firehose of Rust</title>

        <link rel="stylesheet" href="dist/reset.css">
        <link rel="stylesheet" href="dist/reveal.css">
        <link rel="stylesheet" href="dist/theme/solarized.css" id="theme">

        <!-- Theme used for syntax highlighted code -->
        <link rel="stylesheet" href="plugin/highlight/solarized-dark.css" id="highlight-theme">

        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet">
<style>
.container{
    display: flex;
}
.col{
    flex: 1;
}
tt{
    background-color: #eee8d5;
    padding: 0 .1em;
    border-radius: .2em;
    font-family: 'Ubuntu Mono', monospace;
}
.reveal pre code{
    font-family: 'Ubuntu Mono', monospace;
    max-height: none;
}
.reveal pre ::selection{
    color: #657b83;
    background: #fdf6e3;
}
.wrap {
    display: inline-block;
    text-align: left;
}
</style>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>Three Big Ideas</h1>
                    <h2>A <span style="color: #dc322f">Firehose</span> of Rust for C++ Programmers</h2>
                </section>

                <section data-markdown><textarea data-template>
Rust is a big language. We won't get to:

- syntax
- enums (tagged unions) and <tt>Option</tt>
- error handling with <tt>Result</tt> and <tt>?</tt>
- generics (templates) and traits
- <tt>unsafe</tt> code
- <tt>extern</tt> and interoperating with C
- Cargo
                 </textarea></section>

                <section data-markdown><textarea data-template>
# References

**shared references**, <tt>&T</tt>, like <tt>const</tt> pointers in C/C++

**mutable references**, <tt>&mut T</tt>, like non-<tt>const</tt> pointers in C/C++

References don't keep things alive. There is no garbage collector.

## BIG IDEA #1

References are always valid. No dangling pointers.

## BIG IDEA #2

Mutable references are unique. No mutable aliasing.
                 </textarea></section>




                <section data-markdown><textarea data-template>
# BIG IDEA #1

References are always valid. No dangling pointers.
                 </textarea></section>




                <section style="font-size: 2em">
                    A dangling pointer
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  int *my_int_ptr;
  {
    int my_int = 5;
    my_int_ptr = &my_int;
  }
  cout << *my_int_ptr;
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let my_int_ptr: &i32;
    {
        let my_int: i32 = 5;
        my_int_ptr = &my_int;
    }
    dbg!(*my_int_ptr);
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.5em">
                    C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  int *my_int_ptr;
  {
    int my_int = 5;
    my_int_ptr = &my_int;
  }
  cout << *my_int_ptr;
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
==22092==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7fff2648dfe0 at pc 0x557a54f3a306 bp 0x7fff2648dfa0 sp 0x7fff2648df90
READ of size 4 at 0x7fff2648dfe0 thread T0
    #0 0x557a54f3a305 in main (/home/jacko/cpp_rust_talk/1.a.lifetimes/simple_scope+0x1305)
    #1 0x7f76b8ba6b24 in __libc_start_main (/usr/lib/libc.so.6+0x27b24)
    #2 0x557a54f3a12d in _start (/home/jacko/cpp_rust_talk/1.a.lifetimes/simple_scope+0x112d)
                            </script></code></pre>
                </section>

                <section style="font-size: 1.5em">
                    Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let my_int_ptr: &i32;
    {
        let my_int: i32 = 5;
        my_int_ptr = &my_int;
    }
    dbg!(*my_int_ptr);
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
error[E0597]: `my_int` does not live long enough
 --> src/main.rs:5:22
  |
5 |         my_int_ptr = &my_int;
  |                      ^^^^^^^ borrowed value does not live long enough
6 |     }
  |     - `my_int` dropped here while still borrowed
7 |     dbg!(*my_int_ptr);
  |          ----------- borrow later used here
                            </script></code></pre>
                </section>



                <section style="font-size: 1.75em">
                    A borrowing view
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  string my_string =
      "abcdefghijklmnopqrstuvwxy";
  string_view my_string_view =
      my_string + "z";
  cout << my_string_view;
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let my_string: String =
        "abcdefghijklmnopqrstuvwxy".to_string();
    let my_string_view: &str =
        (my_string + "z").as_str();
    dbg!(my_string_view);
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.5em">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  string my_string =
      "abcdefghijklmnopqrstuvwxy";
  string_view my_string_view =
      my_string + "z";
  cout << my_string_view;
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
==24774==ERROR: AddressSanitizer: heap-use-after-free on address 0x6060000000e0 at pc 0x7f63fa6020b6 bp 0x7fff1828aa30 sp 0x7fff1828a1d8
READ of size 26 at 0x6060000000e0 thread T0
    #0 0x7f63fa6020b5 in __interceptor_fwrite /build/gcc/src/gcc/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:1139
    #1 0x7f63fa512d13 in std::basic_streambuf<char, std::char_traits<char> >::sputn(char const*, long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:458
    #2 0x7f63fa512d13 in void std::__ostream_write<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*, long) /build/gcc/src/gcc-build/x86_64-pc-lin
ux-gnu/libstdc++-v3/include/bits/ostream_insert.h:50
    #3 0x7f63fa512d13 in std::basic_ostream<char, std::char_traits<char> >& std::__ostream_insert<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const
*, long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/ostream_insert.h:101
    #4 0x55a0098b0cba in std::basic_ostream<char, std::char_traits<char> >& std::operator<< <char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, std::basic_stri
ng_view<char, std::char_traits<char> >) (/home/jacko/cpp_rust_talk/1.a.lifetimes/string_view+0x2cba)
    #5 0x55a0098b0627 in main (/home/jacko/cpp_rust_talk/1.a.lifetimes/string_view+0x2627)
    #6 0x7f63fa0e0b24 in __libc_start_main (/usr/lib/libc.so.6+0x27b24)
    #7 0x55a0098b030d in _start (/home/jacko/cpp_rust_talk/1.a.lifetimes/string_view+0x230d)
                            </script></code></pre>
                </section>

                <section style="font-size: 1.4em">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let my_string: String =
        "abcdefghijklmnopqrstuvwxy".to_string();
    let my_string_view: &str =
        (my_string + "z").as_str();
    dbg!(my_string_view);
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
error[E0716]: temporary value dropped while borrowed
 --> src/main.rs:5:9
  |
5 |         (my_string + "z").as_str();
  |         ^^^^^^^^^^^^^^^^^         - temporary value is freed at the end of this statement
  |         |
  |         creates a temporary which is freed while still in use
6 |     dbg!(my_string_view);
  |          -------------- borrow later used here
  |
  = note: consider using a `let` binding to create a longer lived value
                            </script></code></pre>
                </section>



                <section style="font-size: 1.5em">
                    A long-lived container
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<string_view> my_vector;
  {
    string my_string = "hello world";
    my_vector.push_back(my_string);
  }
  cout << my_vector[0];
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut my_vector: Vec<&str> = Vec::new();
    {
        let my_string = "hello world".to_string();
        my_vector.push(&my_string);
    }
    dbg!(my_vector);
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.5em">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<string_view> my_vector;
  {
    string my_string = "hello world";
    my_vector.push_back(my_string);
  }
  cout << my_vector[0];
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
==27916==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffeabade130 at pc 0x7f260741b0b6 bp 0x7ffeabaddf30 sp 0x7ffeabadd6d8
READ of size 11 at 0x7ffeabade130 thread T0
    #0 0x7f260741b0b5 in __interceptor_fwrite /build/gcc/src/gcc/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:1139
    #1 0x7f260732bd13 in std::basic_streambuf<char, std::char_traits<char> >::sputn(char const*, long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:458
    #2 0x7f260732bd13 in void std::__ostream_write<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*, long) /build/gcc/src/gcc-build/x86_64-pc-lin
ux-gnu/libstdc++-v3/include/bits/ostream_insert.h:50
    #3 0x7f260732bd13 in std::basic_ostream<char, std::char_traits<char> >& std::__ostream_insert<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const
*, long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/ostream_insert.h:101
    #4 0x55b1c18ddec4 in std::basic_ostream<char, std::char_traits<char> >& std::operator<< <char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, std::basic_stri
ng_view<char, std::char_traits<char> >) (/home/jacko/cpp_rust_talk/1.a.lifetimes/vector_push+0x2ec4)
    #5 0x55b1c18dd602 in main (/home/jacko/cpp_rust_talk/1.a.lifetimes/vector_push+0x2602)
    #6 0x7f2606ef9b24 in __libc_start_main (/usr/lib/libc.so.6+0x27b24)
    #7 0x55b1c18dd32d in _start (/home/jacko/cpp_rust_talk/1.a.lifetimes/vector_push+0x232d)
                            </script></code></pre>
                </section>
                <section style="font-size: 1.5em">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut my_vector: Vec<&str> = Vec::new();
    {
        let my_string = "hello world".to_string();
        my_vector.push(&my_string);
    }
    dbg!(my_vector);
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
error[E0597]: `my_string` does not live long enough
 --> src/main.rs:5:24
  |
5 |         my_vector.push(&my_string);
  |                        ^^^^^^^^^^ borrowed value does not live long enough
6 |     }
  |     - `my_string` dropped here while still borrowed
7 |     dbg!(my_vector);
  |          --------- borrow later used here
                            </script></code></pre>
                </section>



                <section style="font-size: 1.2em">
                    An invalid function
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
void my_push_back(vector<string_view> &v, string_view s) {
  v.push_back(s);
}

int main() {
  vector<string_view> my_vector;
  {
    string my_string = "hello world";
    my_push_back(my_vector, my_string);
  }
  cout << my_vector[0];
}
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
fn my_push_back(v: &mut Vec<&str>, s: &str) {
    v.push(s);
}

fn main() {
    let mut my_vector: Vec<&str> = Vec::new();
    {
        let my_string = "hello world".to_string();
        my_push_back(&mut my_vector, &my_string);
    }
    dbg!(my_vector);
}
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.2em">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
void my_push_back(vector<string_view> &v, string_view s) {
  v.push_back(s);
}

int main() {
  vector<string_view> my_vector;
  {
    string my_string = "hello world";
    my_push_back(my_vector, my_string);
  }
  cout << my_vector[0];
}
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
==29475==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffe1aa46e00 at pc 0x7fcb06d9d0b6 bp 0x7ffe1aa46c20 sp 0x7ffe1aa463c8
READ of size 11 at 0x7ffe1aa46e00 thread T0
    #0 0x7fcb06d9d0b5 in __interceptor_fwrite /build/gcc/src/gcc/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:1139
    #1 0x7fcb06cadd13 in std::basic_streambuf<char, std::char_traits<char> >::sputn(char const*, long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/streambuf:458
    #2 0x7fcb06cadd13 in void std::__ostream_write<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*, long) /build/gcc/src/gcc-build/x86_64-pc-lin
ux-gnu/libstdc++-v3/include/bits/ostream_insert.h:50
    #3 0x7fcb06cadd13 in std::basic_ostream<char, std::char_traits<char> >& std::__ostream_insert<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const
*, long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/ostream_insert.h:101
    #4 0x5581bb9bc002 in std::basic_ostream<char, std::char_traits<char> >& std::operator<< <char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, std::basic_stri
ng_view<char, std::char_traits<char> >) (/home/jacko/cpp_rust_talk/1.a.lifetimes/vector_push_fn+0x3002)
    #5 0x5581bb9bb6be in main (/home/jacko/cpp_rust_talk/1.a.lifetimes/vector_push_fn+0x26be)
    #6 0x7fcb0687bb24 in __libc_start_main (/usr/lib/libc.so.6+0x27b24)
    #7 0x5581bb9bb32d in _start (/home/jacko/cpp_rust_talk/1.a.lifetimes/vector_push_fn+0x232d) 
                            </script></code></pre>
                </section>
                <section style="font-size: 1.2em">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
fn my_push_back(v: &mut Vec<&str>, s: &str) {
    v.push(s);
}

fn main() {
    let mut my_vector: Vec<&str> = Vec::new();
    {
        let my_string = "hello world".to_string();
        my_push_back(&mut my_vector, &my_string);
    }
    dbg!(my_vector);
}
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
error[E0623]: lifetime mismatch
 --> src/main.rs:2:12
  |
1 | fn my_push_back(v: &mut Vec<&str>, s: &str) {
  |                             ----      ---- these two types are declared with different lifetimes...
2 |     v.push(s);
  |            ^ ...but data from `s` flows into `v` here
                            </script></code></pre>
                </section>



                <section style="font-size: 1.2em">
                    An invalid caller
                    <div class="container">
                        <div class="col">
                            Rust (previous)
                            <pre class="rust"><code data-trim><script type="text/template">
fn my_push_back(v: &mut Vec<&str>, s: &str) {
    v.push(s);
}

fn main() {
    let mut my_vector: Vec<&str> = Vec::new();
    {
        let my_string = "hello world".to_string();
        my_push_back(&mut my_vector, &my_string);
    }
    dbg!(my_vector);
}
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust (with explicit lifetimes)
                            <pre class="rust"><code data-trim><script type="text/template">
fn my_push_back<'a>(v: &mut Vec<&'a str>, s: &'a str) {
    v.push(s);
}

fn main() {
    let mut my_vector: Vec<&str> = Vec::new();
    {
        let my_string = "hello world".to_string();
        my_push_back(&mut my_vector, &my_string);
    }
    dbg!(my_vector);
}
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.2em">
                            Rust (with explicit lifetimes)
                            <pre class="rust"><code data-trim><script type="text/template">
fn my_push_back<'a>(v: &mut Vec<&'a str>, s: &'a str) {
    v.push(s);
}

fn main() {
    let mut my_vector: Vec<&str> = Vec::new();
    {
        let my_string = "hello world".to_string();
        my_push_back(&mut my_vector, &my_string);
    }
    dbg!(my_vector);
}
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
error[E0597]: `my_string` does not live long enough
  --> src/main.rs:9:38
   |
9  |         my_push_back(&mut my_vector, &my_string);
   |                                      ^^^^^^^^^^ borrowed value does not live long enough
10 |     }
   |     - `my_string` dropped here while still borrowed
11 |     dbg!(my_vector);
   |          --------- borrow later used here
                            </script></code></pre>
                </section>




                <section data-markdown><textarea data-template>
# BIG IDEA #2

Mutable references are unique. No mutable aliasing.
                 </textarea></section>



                <section style="font-size: 2em">
                    Mutable aliasing
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  int my_int = 5;
  int &reference1 = my_int;
  int &reference2 = my_int;
  reference1++;
  reference2++;
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut my_int = 5;
    let reference1 = &mut my_int;
    let reference2 = &mut my_int;
    *reference1 += 1;
    *reference2 += 1;
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.5em">
                    Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut my_int = 5;
    let reference1 = &mut my_int;
    let reference2 = &mut my_int;
    *reference1 += 1;
    *reference2 += 1;
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
error[E0499]: cannot borrow `my_int` as mutable more than once at a time
 --> src/main.rs:4:22
  |
3 |     let reference1 = &mut my_int;
  |                      ----------- first mutable borrow occurs here
4 |     let reference2 = &mut my_int;
  |                      ^^^^^^^^^^^ second mutable borrow occurs here
5 |     *reference1 += 1;
  |     ---------------- first borrow later used here
                            </script></code></pre>
                </section>



                <section style="font-size: 2em">
                    Sidebar: mutable aliasing in assembly
                    <a href="https://godbolt.org/z/891s6z4Tb"><img src="godbolt_aliasing.png"></a>
                </section>



                <section style="font-size: 1.5em">
                    Multiple references into an array
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  array<char, 2> char_array = {'a', 'b'};
  char &first_element = char_array[0];
  const char &second_element = char_array[1];
  first_element = second_element;
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut char_array: [char; 2] = ['a', 'b'];
    let first_element = &mut char_array[0];
    let second_element = &char_array[1];
    *first_element = *second_element;
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.5em">
                    Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut char_array: [char; 2] = ['a', 'b'];
    let first_element = &mut char_array[0];
    let second_element = &char_array[1];
    *first_element = *second_element;
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
error[E0502]: cannot borrow `char_array[_]` as immutable because it is also borrowed as mutable
 --> src/main.rs:6:26
  |
5 |     let first_element = &mut char_array[0];
  |                         ------------------ mutable borrow occurs here
6 |     let second_element = &char_array[1];
  |                          ^^^^^^^^^^^^^^ immutable borrow occurs here
7 |     *first_element = *second_element;
  |     -------------------------------- mutable borrow later used here
                            </script></code></pre>
                </section>
                <section style="font-size: 1.3em">
                    There's more than one way to do it
                    <div class="container">
                        <div class="col">
                            indexes
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut char_array: [char; 2] = ['a', 'b'];
    char_array[0] = char_array[1];
                            </script></code></pre>
                            .split_at_mut()
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut char_array: [char; 2] = ['a', 'b'];
    let (first_slice, rest_slice) = char_array.split_at_mut(1);
    let first_element = &mut first_slice[0];
    let second_element = &rest_slice[0];
    *first_element = *second_element;
                            </script></code></pre>
                            pattern matching
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut char_array: [char; 2] = ['a', 'b'];
    let [first_element, second_element] = &mut char_array;
    *first_element = *second_element;
                            </script></code></pre>
                        </div>
                        <div class="col">
                            .iter_mut()
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut char_array: [char; 2] = ['a', 'b'];
    let mut array_iterator = char_array.iter_mut();
    let first_element = array_iterator.next().unwrap();
    let second_element = array_iterator.next().unwrap();
    *first_element = *second_element;
                            </script></code></pre>
                            ☠ unsafe code ☠
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut char_array: [char; 2] = ['a', 'b'];
    let first_element: *mut char = &mut char_array[0];
    let second_element: *const char = &char_array[1];
    unsafe {
        *first_element = *second_element;
    }
                            </script></code></pre>
                        </div>
                    </div>
                </section>





                <section style="font-size: 1.4em">
                    Invalidating a reference by reallocating
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
void push_int_twice(vector<int> &v, const int &n) {
  v.push_back(n);
  v.push_back(n);
}

int main() {
  vector<int> my_vector = {0};
  const int &my_int_reference = my_vector[0];
  push_int_twice(my_vector, my_int_reference);
}
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
fn push_int_twice(v: &mut Vec<i32>, n: &i32) {
    v.push(*n);
    v.push(*n);
}

fn main() {
    let mut my_vector = vec![0];
    let my_int_reference = &my_vector[0];
    push_int_twice(&mut my_vector, my_int_reference);
}
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.4em">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
void push_int_twice(vector<int> &v, const int &n) {
  v.push_back(n);
  v.push_back(n);
}

int main() {
  vector<int> my_vector = {0};
  const int &my_int_reference = my_vector[0];
  push_int_twice(my_vector, my_int_reference);
}
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
==42920==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000010 at pc 0x5629133874f3 bp 0x7ffe3befabe0 sp 0x7ffe3befabd0                                                       READ of size 4 at 0x602000000010 thread T0
    #0 0x5629133874f2 in void __gnu_cxx::new_allocator<int>::construct<int, int const&>(int*, int const&) (/home/jacko/cpp_rust_talk/1.b.mutability/vector_invalidate+0x24f2)                      #1 0x56291338697c in void std::allocator_traits<std::allocator<int> >::construct<int, int const&>(std::allocator<int>&, int*, int const&) (/home/jacko/cpp_rust_talk/1.b.mutability/vector_
invalidate+0x197c)                                                                                                                                                                                 #2 0x562913386d9b in void std::vector<int, std::allocator<int> >::_M_realloc_insert<int const&>(__gnu_cxx::__normal_iterator<int*, std::vector<int, std::allocator<int> > >, int const&) (/
home/jacko/cpp_rust_talk/1.b.mutability/vector_invalidate+0x1d9b)                                                                                                                                  #3 0x562913386672 in std::vector<int, std::allocator<int> >::push_back(int const&) (/home/jacko/cpp_rust_talk/1.b.mutability/vector_invalidate+0x1672)
    #4 0x5629133862be in push_int_twice(std::vector<int, std::allocator<int> >&, int const&) (/home/jacko/cpp_rust_talk/1.b.mutability/vector_invalidate+0x12be)                                   #5 0x562913386452 in main (/home/jacko/cpp_rust_talk/1.b.mutability/vector_invalidate+0x1452)
    #6 0x7f1db0fa8b24 in __libc_start_main (/usr/lib/libc.so.6+0x27b24)                                                                                                                            #7 0x5629133861bd in _start (/home/jacko/cpp_rust_talk/1.b.mutability/vector_invalidate+0x11bd)
                            </script></code></pre>
                </section>
                <section style="font-size: 1.4em">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
fn push_int_twice(v: &mut Vec<i32>, n: &i32) {
    v.push(*n);
    v.push(*n);
}

fn main() {
    let mut my_vector = vec![0];
    let my_int_reference = &my_vector[0];
    push_int_twice(&mut my_vector, my_int_reference);
}
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
error[E0502]: cannot borrow `my_vector` as mutable because it is also borrowed as immutable
  --> src/main.rs:12:20
   |
11 |     let my_int_reference = &my_vector[0];
   |                             --------- immutable borrow occurs here
12 |     push_int_twice(&mut my_vector, my_int_reference);
   |                    ^^^^^^^^^^^^^^  ---------------- immutable borrow later used here
   |                    |
   |                    mutable borrow occurs here
                            </script></code></pre>
                </section>





                <section style="font-size: 1.5em">
                    <p>Herb Sutter's aliased <tt>shared_ptr</tt> pitfall</p>

                    <iframe width="1120" height="630" src="https://www.youtube.com/embed/xnqTKD8uD64?start=1380" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                </section>





                <section style="font-size: 1em">
                    Magical multithreading
                    <div class="container">
                        <div class="col">
                            <p>C++</p>
                            <p><tt>for</tt> loop</p>
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<int> v = vector_of_ints();
  for (auto &x : v) {
    x++;
  }
                            </script></code></pre>
                            <p>serial <tt>for_each</tt></p>
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<int> v = vector_of_ints();
  for_each(v.begin(), v.end(), [](int &x) {
    x++;
  });
                            </script></code></pre>
                            <p>C++17 parallel <tt>for_each</tt></p>
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<int> v = vector_of_ints();
  for_each(execution::par, v.begin(), v.end(), [](int &x) {
    x++;
  });
                            </script></code></pre>
                        </div>
                        <div class="col">
                            <p>Rust</p>
                            <p><tt>for</tt> loop</p>
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut v: Vec<i32> = vector_of_ints();
    for x in &mut v {
        *x += 1;
    }
                            </script></code></pre>
                            <p>serial <tt>for_each</tt></p>
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut v: Vec<i32> = vector_of_ints();
    v.iter_mut().for_each(|x| {
        *x += 1;
    });
                            </script></code></pre>
                            <p>Rayon parallel <tt>for_each</tt></p>
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut v: Vec<i32> = vector_of_ints();
    v.par_iter_mut().for_each(|x| {
        *x += 1;
    });
                            </script></code></pre>
                        </div>
                    </div>
                </section>





                <section>
                    Tragical multithreading
                    <div class="container">
                        <div class="col">
                            <p>C++</p>
                            <p><tt>for</tt> loop</p>
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<int> v = vector_of_ints();
  int sum = 0;
  for (auto &x : v) {
    x++;
    sum += x;
  }
                            </script></code></pre>
                            <p>serial <tt>for_each</tt></p>
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<int> v = vector_of_ints();
  int sum = 0;
  for_each(v.begin(), v.end(), [&](int &x) {
    x++;
    sum += x;
  });
                            </script></code></pre>
                            <p>C++17 parallel <tt>for_each</tt></p>
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<int> v = vector_of_ints();
  int sum = 0;
  for_each(execution::par, v.begin(), v.end(), [&](int &x) {
    x++;
    sum += x;
  });
                            </script></code></pre>
                        </div>
                        <div class="col">
                            <p>Rust</p>
                            <p><tt>for</tt> loop</p>
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut v: Vec<i32> = vector_of_ints();
    let mut sum = 0;
    for x in &mut v {
        *x += 1;
        sum += *x;
    }
                            </script></code></pre>
                            <p>serial <tt>for_each</tt></p>
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut v: Vec<i32> = vector_of_ints();
    let mut sum = 0;
    v.iter_mut().for_each(|x| {
        *x += 1;
        sum += *x;
    });
                            </script></code></pre>
                            <p>Rayon parallel <tt>for_each</tt></p>
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut v: Vec<i32> = vector_of_ints();
    let mut sum = 0;
    v.par_iter_mut().for_each(|x| {
        *x += 1;
        sum += *x;
    });
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.5em">
                    Rayon parallel <tt>for_each</tt>
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut v: Vec<i32> = vector_of_ints();
    let mut sum = 0;
    v.par_iter_mut().for_each(|x| {
        *x += 1;
        sum += *x;
    });
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
   error[E0594]: cannot assign to `sum`, as it is a captured variable in a `Fn` closure
  --> src/main.rs:62:9
   |
62 |         sum += *x;
   |         ^^^^^^^^^ cannot assign
                            </script></code></pre>
                </section>




                <section style="font-size: 2em">
                    How does Rust know?
                    <div style="width: 60%; margin: 1em auto">
                            <pre class="rust"><code data-trim data-line-numbers="|2-3"><script type="text/template">
    fn for_each<OP>(self, op: OP)
    where
        OP: Fn(Self::Item) + Sync + Send,
    {
        for_each::for_each(self, &op)
    }
                            </script></code></pre>
                    </div>
                </section>





                <section style="font-size: 1.3em">
                    Synchronizing shared state
                    <div class="container">
                        <div class="col">
                            <p>C++</p>
                            <p><tt>atomic&lt;int&gt;</tt></p>
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<int> v = vector_of_ints();
  atomic<int> sum = 0;
  for_each(execution::par, v.begin(), v.end(), [&](int &x) {
    x += 1;
    sum.fetch_add(x, memory_order_relaxed);
  });
                            </script></code></pre>
                            <p><tt>mutex</tt></p>
                            <pre class="cpp"><code data-trim><script type="text/template">
  vector<int> v = vector_of_ints();
  int sum = 0;
  mutex sum_lock;
  for_each(execution::par, v.begin(), v.end(), [&](int &x) {
    x += 1;
    lock_guard<mutex> guard(sum_lock);
    sum += x;
  });
                            </script></code></pre>
                        </div>
                        <div class="col">
                            <p>Rust</p>
                            <p><tt>AtomicI32</tt></p>
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut v: Vec<i32> = vector_of_ints();
    let sum: AtomicI32 = AtomicI32::new(0);
    v.par_iter_mut().for_each(|x| {
        *x += 1;
        sum.fetch_add(*x, Ordering::Relaxed);
    });
                            </script></code></pre>
                            <p><tt>Mutex&lt;i32&gt;</tt></p>
                            <pre class="rust"><code data-trim><script type="text/template">
    let mut v: Vec<i32> = vector_of_ints();
    let sum: Mutex<i32> = Mutex::new(0);
    v.par_iter_mut().for_each(|x| {
        *x += 1;
        let mut guard: MutexGuard<i32> =
            sum.lock().unwrap();
        *guard += *x;
    });
                            </script></code></pre>
                        </div>
                    </div>
                </section>






                <section data-markdown><textarea data-template>
# Move Semantics

"Plain old data" types like <tt>i32</tt> and <tt>&T</tt> are <tt>Copy</tt>.

<p>

<div class="wrap">
    By-value operations (like assignment, parameter passing,<br>
    and returning) on <tt>Copy</tt> types are bitwise copies, like in C.
</div>

Other types like <tt>Vec&amp;lt;i32&amp;gt;</tt> and <tt>&mut T</tt> are non-<tt>Copy</tt>.

<p>

## BIG IDEA #3

<p>

<div class="wrap">
    By-value operations on non-<tt>Copy</tt> types are moves. Moves<br>
    are <u>destructive bitwise copies</u>, and everything is movable.
</div>
                 </textarea></section>





                <section style="font-size: 1.5em">
                    Moving a string
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
    string s1 = "abcdefghijklmnopqrstuvwxyz";
    string s2 = move(s1);
    vector<string> v;
    v.push_back(move(s2));
                            </script></code></pre>
                            one string allocation<br/>
                            <u>three</u> string destructors
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
        let s1 = "abcdefghijklmnopqrstuvwxyz".to_string();
        let s2 = s1;
        let mut v = Vec::new();
        v.push(s2);
                            </script></code></pre>
                            one string allocation<br/>
                            <u>one</u> string destructor
                        </div>
                    </div>
                </section>





                <section style="font-size: 1.5em">
                    Copying a string
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
    string s1 = "abcdefghijklmnopqrstuvwxyz";
    string s2 = s1;
    vector<string> v;
    v.push_back(s2);
                            </script></code></pre>
                            three string allocations<br/>
                            three string destructors
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
        let s1 = "abcdefghijklmnopqrstuvwxyz".to_string();
        let s2 = s1.clone();
        let mut v = Vec::new();
        v.push(s2.clone());
                            </script></code></pre>
                            three string allocations<br/>
                            three string destructors
                        </div>
                    </div>
                </section>





                <section style="font-size: 1.5em">
                    Accessing a moved-from object
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
    string s1 = "abcdefghijklmnopqrstuvwxyz";
    string s2 = move(s1);
    cout << s1;
                            </script></code></pre>
                            on my box:<br>
                            <tt>s1 == ""</tt>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
        let s1 = "abcdefghijklmnopqrstuvwxyz".to_string();
        let s2 = s1;
        dbg!(s1);
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.5em">
                    Rust
                            <pre class="rust"><code data-trim><script type="text/template">
        let s1 = "abcdefghijklmnopqrstuvwxyz".to_string();
        let s2 = s1;
        dbg!(s1);
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
error[E0382]: use of moved value: `s1`
  --> src/main.rs:26:14
   |
24 |         let s1 = "abcdefghijklmnopqrstuvwxyz".to_string();
   |             -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
25 |         let s2 = s1;
   |                  -- value moved here
26 |         dbg!(s1);
   |              ^^ value used here after move
                            </script></code></pre>
                </section>





                <section style="font-size: 1.5em">
                    Moving a borrowed object
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
    string s1 = "abcde";
    string_view my_view = s1;
    string s2 = move(s1);
    cout << my_view;
                            </script></code></pre>
                            on my box:<br>
                            <tt>my_view == "\0bcde"</tt>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
        let s1 = "abcde".to_string();
        let my_view = s1.as_str();
        let s2 = s1;
        dbg!(my_view);
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.5em">
                    Rust
                            <pre class="rust"><code data-trim><script type="text/template">
        let s1 = "abcde".to_string();
        let my_view = s1.as_str();
        let s2 = s1;
        dbg!(my_view);
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
error[E0505]: cannot move out of `s1` because it is borrowed
  --> src/main.rs:31:18
   |
30 |         let my_view = s1.as_str();
   |                       -- borrow of `s1` occurs here
31 |         let s2 = s1;
   |                  ^^ move out of `s1` occurs here
32 |         dbg!(my_view);
   |              ------- borrow later used here
                            </script></code></pre>
                </section>





                <section style="font-size: 1.5em">
                    Moving a string again
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
    string s1 = "abcdefghijklmnopqrstuvwxyz";
    string s2 = move(s1);
    vector<string> v;
    v.push_back(move(s2));
    string s3 = move(v[0]);
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
        let s1 = "abcdefghijklmnopqrstuvwxyz".to_string();
        let s2 = s1;
        let mut v = Vec::new();
        v.push(s2);
        let s3 = v[0];
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.5em">
                    Rust
                            <pre class="rust"><code data-trim><script type="text/template">
        let s1 = "abcdefghijklmnopqrstuvwxyz".to_string();
        let s2 = s1;
        let mut v = Vec::new();
        v.push(s2);
        let s3 = v[0];
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
error[E0507]: cannot move out of index of `Vec<String>`
  --> src/main.rs:86:18
   |
86 |         let s3 = v[0];
   |                  ^^^^
   |                  |
   |                  move occurs because value has type `String`, which does not implement the `Copy` trait
   |                  help: consider borrowing here: `&v[0]`
                            </script></code></pre>
                </section>





                <section style="font-size: 1.3em">
                    Moving through a reference
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
void f(string &s1) {
  string s2 = move(s1);
  cout << s2;
}

void g() {
  string s1 = "foo";
  f(s1);
  cout << s1;
}
                            </script></code></pre>
                            on my box:<br>
                            <tt>s1 == ""</tt><br>
                            <tt>s2 == "foo"</tt>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    fn f(s1: &mut String) {
        let s2 = *s1;
        dbg!(s2);
    }

    fn g() {
        let mut s1 = "foo".to_string();
        f(&mut s1);
        dbg!(s1);
    }
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.3em">
                    Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    fn f(s1: &mut String) {
        let s2 = *s1;
        dbg!(s2);
    }

    fn g() {
        let mut s1 = "foo".to_string();
        f(&mut s1);
        dbg!(s1);
    }
                            </script></code></pre>
                            <pre style="width: 90%"><code data-trim><script type="text/template">
error[E0507]: cannot move out of `*s1` which is behind a mutable reference
 --> src/main.rs:7:14
  |
7 |     let s2 = *s1;
  |              ^^^
  |              |
  |              move occurs because `*s1` has type `String`, which does not implement the `Copy` trait
  |              help: consider borrowing here: `&*s1`
                            </script></code></pre>
                </section>





                <section style="font-size: 1.3em">
                    There's more than one way to do it
                    <div class="container">
                        <div class="col">
                            <tt>mem::swap</tt>
                            <pre class="rust"><code data-trim><script type="text/template">
    fn f(s1: &mut String) {
        let mut s2 = "".to_string();
        mem::swap(s1, &mut s2);
        dbg!(s2);
    }

    fn g() {
        let mut s1 = "foo".to_string();
        f(&mut s1);
        dbg!(s1);
    }
                            </script></code></pre>
                            <tt>s1 == ""</tt><br>
                            <tt>s2 == "foo"</tt><br>
                        </div>
                        <div class="col">
                            <tt>Option::take</tt>
                            <pre class="rust"><code data-trim><script type="text/template">
    fn f(s1: &mut Option<String>) {
        let s2 = s1.take().unwrap();
        dbg!(s2);
    }

    fn g() {
        let mut s1: Option<String> =
            Some("foo".to_string());
        f(&mut s1);
        dbg!(s1);
    }
                            </script></code></pre>
                            <tt>s1 == None</tt><br>
                            <tt>s2 == "foo"</tt><br>
                        </div>
                        <div class="col">
                            <tt>Vec::remove</tt>
                            <pre class="rust"><code data-trim><script type="text/template">
    fn f(v: &mut Vec<String>) {
        let s2 = v.remove(0);
        dbg!(s2);
    }

    fn g() {
        let mut v = vec![
            "foo".to_string(),
            "bar".to_string(),
            "baz".to_string(),
        ];
        f(&mut v);
        dbg!(v);
    }
                            </script></code></pre>
                            <tt>v == ["bar", "baz"]</tt><br>
                            <tt>s2 == "foo"</tt><br>
                        </div>
                    </div>
                </section>





                <section style="font-size: 2em">
                    The <tt>drop</tt> function
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
    fstream file("/dev/null");
    file.close();
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
        let file = File::open("/dev/null")?;
        drop(file);
                            </script></code></pre>
                        </div>
                    </div>
                </section>





                <section style="font-size: 2em">
                    Surprise: <tt>drop</tt> is the empty function
                    <br>
                    <br>
                            <pre class="rust" style="width: 50%; font-size: 0.9em"><code data-trim><script type="text/template">
        pub fn drop<T>(_x: T) {}
                            </script></code></pre>
                </section>




                <section id="tradeoffs-slide" style="font-size: 1.0em">
<style>
#tradeoffs-slide li {
    margin: 1em;
}
</style>
                    <h2>Move Semantics Tradeoffs</h2>
                    <div class="container">
                        <div class="col">
                            <h3>C++ strengths</h3>
<ul>
    <li>Immovable types are supported.</li>
    <li><tt>mutex</tt> in C++ doesn't require heap allocation. <tt>Mutex</tt> in Rust does, to make itself movable on Unix.</li>
    <li>Complex moves are supported.</li>
    <li>GCC <tt>string</tt> has a branch-free small string optimization. This isn't possible in Rust, because it's not bitwise movable.</li>
</ul>
                            </textarea>
                        </div>
                        <div class="col">
                            <h3>Rust strengths</h3>
<ul>
    <li>All types are movable, and all moves are infallible.</li>
    <li><tt>Vec</tt> growing and shifting can always <tt>memmove</tt>.</li>
    <li>Types don't need a moved-from state. <tt>unique_ptr&lt;T&gt;</tt> in C++ has to be nullable to be movable, but <tt>Box&lt;T&gt;</tt> in Rust doesn't.</li>
    <li>Constructors are regular functions; <tt>new</tt> isn't a keyword.</li>
</ul>
                        </div>
                    </div>
                </section>






                <section style="font-size: 2em">
                    Sidebar: <tt>memmove</tt> in <tt>Vec::remove</tt>
                    <a href="https://godbolt.org/z/fK1WchMYf"><img src="godbolt_erase.png"></a>
                </section>





                <section>
                    <h1>Putting it all together</h1>
                    <tt style="font-size: 2em">Arc&lt;Mutex&lt;String&gt;&gt;</tt>
                </section>




                <section style="font-size: 1.3em">
                    A mutex on the stack
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  string my_string;
  mutex my_mutex;
  vector<thread> thread_handles;
  for (int i = 0; i < 10; i++) {
    thread thread_handle([&] {
      lock_guard<mutex> guard(my_mutex);
      my_string += "some characters";
    });
    thread_handles.push_back(move(thread_handle));
  }
  for (auto &thread_handle : thread_handles) {
    thread_handle.join();
  }
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let my_string: Mutex<String> = Mutex::new(String::new());
    let mut thread_handles = Vec::new();
    for _ in 0..10 {
        let thread_handle = thread::spawn(|| {
            let mut guard: MutexGuard<String> =
                my_string.lock().unwrap();
            guard.push_str("some characters");
        });
        thread_handles.push(thread_handle);
    }
    for thread_handle in thread_handles {
        thread_handle.join().unwrap();
    }
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.3em">
                    Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let my_string: Mutex<String> = Mutex::new(String::new());
    let mut thread_handles = Vec::new();
    for _ in 0..10 {
        let thread_handle = thread::spawn(|| {
            let mut guard: MutexGuard<String> =
                my_string.lock().unwrap();
            guard.push_str("some characters");
        });
        thread_handles.push(thread_handle);
    }
    for thread_handle in thread_handles {
        thread_handle.join().unwrap();
    }
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
error[E0373]: closure may outlive the current function, but it borrows `my_string`, which is owned by the current function
  --> src/main.rs:9:43
   |
9  |         let thread_handle = thread::spawn(|| {
   |                                           ^^ may outlive borrowed value `my_string`
10 |             let mut guard: MutexGuard<String> =
11 |                 my_string.lock().unwrap();
   |                 --------- `my_string` is borrowed here
   |
                            </script></code></pre>
                </section>




                <section style="font-size: 1.5em">
                    How does Rust know?
                    <div class="container">
                        <div class="col">
                            <tt>for_each</tt>
                            <pre class="rust"><code data-trim data-line-numbers="|2-3"><script type="text/template">
    fn for_each<OP>(self, op: OP)
    where
        OP: Fn(Self::Item) + Sync + Send,
    {
        for_each::for_each(self, &op)
    }
                            </script></code></pre>
                        </div>
                        <div class="col">
                            <tt>spawn</tt>
                            <pre class="rust"><code data-trim data-line-numbers="|2-5"><script type="text/template">
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static,
{
    Builder::new()
        .spawn(f)
        .expect("failed to spawn thread")
}
                            </script></code></pre>
                        </div>
                    </div>
                </section>




                <section style="font-size: 1.5em">
                    A mutex on the heap
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim><script type="text/template">
  shared_ptr<pair<mutex, string>> my_pair =
      make_shared<pair<mutex, string>>();
  vector<thread> thread_handles;
  for (int i = 0; i < 10; i++) {
    thread thread_handle([=] {
      lock_guard<mutex> guard(my_pair->first);
      my_pair->second += "some characters";
    });
    thread_handles.push_back(move(thread_handle));
  }
  for (auto &thread_handle : thread_handles) {
    thread_handle.join();
  }
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim><script type="text/template">
    let my_string: Arc<Mutex<String>> =
        Arc::new(Mutex::new(String::new()));
    let mut thread_handles = Vec::new();
    for _ in 0..10 {
        let arc_clone = my_string.clone();
        let thread_handle = thread::spawn(move || {
            let mut guard: MutexGuard<String> =
                arc_clone.lock().unwrap();
            guard.push_str("some characters");
        });
        thread_handles.push(thread_handle);
    }
    for thread_handle in thread_handles {
        thread_handle.join().unwrap();
    }
                            </script></code></pre>
                        </div>
                    </div>
                </section>




                <section style="font-size: 1.3em">
                    Forgetting the mutex
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim data-line-numbers="|6"><script type="text/template">
  shared_ptr<pair<mutex, string>> my_pair =
      make_shared<pair<mutex, string>>();
  vector<thread> thread_handles;
  for (int i = 0; i < 10; i++) {
    thread thread_handle([=] {
      my_pair->second += "some characters";
    });
    thread_handles.push_back(move(thread_handle));
  }
  for (auto &thread_handle : thread_handles) {
    thread_handle.join();
  }
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim data-line-numbers="|1,6"><script type="text/template">
    let my_string: Arc<String> = Arc::new(String::new());
    let mut thread_handles = Vec::new();
    for _ in 0..10 {
        let mut arc_clone = my_string.clone();
        let thread_handle = thread::spawn(move || {
            arc_clone.push_str("some characters");
        });
        thread_handles.push(thread_handle);
    }
    for thread_handle in thread_handles {
        thread_handle.join().unwrap();
    }
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.3em">
                            C++
                            <pre class="cpp"><code data-trim data-line-numbers="6"><script type="text/template">
  shared_ptr<pair<mutex, string>> my_pair =
      make_shared<pair<mutex, string>>();
  vector<thread> thread_handles;
  for (int i = 0; i < 10; i++) {
    thread thread_handle([=] {
      my_pair->second += "some characters";
    });
    thread_handles.push_back(move(thread_handle));
  }
  for (auto &thread_handle : thread_handles) {
    thread_handle.join();
  }
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
WARNING: ThreadSanitizer: data race (pid=64280)
  Read of size 8 at 0x7b0800001020 by thread T3:
    #0 memcpy /build/gcc/src/gcc/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:806 (libtsan.so.0+0x41fdd)
    #1 memcpy /build/gcc/src/gcc/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:798 (libtsan.so.0+0x41fdd)
    #2 std::char_traits<char>::copy(char*, char const*, unsigned long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/char_traits.h:395 (libstdc++.so.6+0x13e11f)
    #3 std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/basic_string.h:351 (libstdc++.so.6+0x13e11f)
    #4 std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_S_copy(char*, char const*, unsigned long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/basic_string.h:346 (libstdc++.so.6+0x13e11f)
    #5 std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_mutate(unsigned long, unsigned long, char const*, unsigned long) /build/gcc/src/gcc-build/x86_64-pc-linux-gnu/libstdc++-v3/include/bits/basic_string.tcc:320 (libstdc++.so.6+0x13e11f)
    #6 void std::__invoke_impl<void, forgot_mutex()::{lambda()#1}>(std::__invoke_other, forgot_mutex()::{lambda()#1}&&) <null> (mutex+0x5d42)
    #7 std::__invoke_result<forgot_mutex()::{lambda()#1}>::type std::__invoke<forgot_mutex()::{lambda()#1}>(std::__invoke_result&&, (forgot_mutex()::{lambda()#1}&&)...) <null> (mutex+0x592d)
    #8 void std::thread::_Invoker<std::tuple<forgot_mutex()::{lambda()#1}> >::_M_invoke<0ul>(std::_Index_tuple<0ul>) <null> (mutex+0x557a)
                            </script></code></pre>
                </section>
                <section style="font-size: 1.3em">
                            Rust
                            <pre class="rust"><code data-trim data-line-numbers="6"><script type="text/template">
    let my_string: Arc<String> = Arc::new(String::new());
    let mut thread_handles = Vec::new();
    for _ in 0..10 {
        let mut arc_clone = my_string.clone();
        let thread_handle = thread::spawn(move || {
            arc_clone.push_str("some characters");
        });
        thread_handles.push(thread_handle);
    }
    for thread_handle in thread_handles {
        thread_handle.join().unwrap();
    }
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
error[E0596]: cannot borrow data in an `Arc` as mutable     
  --> src/main.rs:46:13
   |
46 |             arc_clone.push_str("some characters");
   |             ^^^^^^^^^ cannot borrow as mutable 
   |
   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `Arc<String>`
                            </script></code></pre>
                </section>




                <section style="font-size: 1.3em">
                    Writing under a read lock
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim data-line-numbers="|1-2,6"><script type="text/template">
  shared_ptr<pair<shared_mutex, string>> my_pair =
      make_shared<pair<shared_mutex, string>>();
  vector<thread> thread_handles;
  for (int i = 0; i < 10; i++) {
    thread thread_handle([=] {
      shared_lock<shared_mutex> guard(my_pair->first);
      my_pair->second += "some characters";
    });
    thread_handles.push_back(move(thread_handle));
  }
  for (auto &thread_handle : thread_handles) {
    thread_handle.join();
  }
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim data-line-numbers="|1-2,7-8"><script type="text/template">
    let my_string: Arc<RwLock<String>> =
        Arc::new(RwLock::new(String::new()));
    let mut thread_handles = Vec::new();
    for _ in 0..10 {
        let arc_clone = my_string.clone();
        let thread_handle = thread::spawn(move || {
            let mut guard: RwLockReadGuard<String> =
                arc_clone.read().unwrap();
            guard.push_str("some characters");
        });
        thread_handles.push(thread_handle);
    }
    for thread_handle in thread_handles {
        thread_handle.join().unwrap();
    }
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.3em">
                            Rust
                            <pre class="rust"><code data-trim data-line-numbers="1-2,7-8"><script type="text/template">
    let my_string: Arc<RwLock<String>> =
        Arc::new(RwLock::new(String::new()));
    let mut thread_handles = Vec::new();
    for _ in 0..10 {
        let arc_clone = my_string.clone();
        let thread_handle = thread::spawn(move || {
            let mut guard: RwLockReadGuard<String> =
                arc_clone.read().unwrap();
            guard.push_str("some characters");
        });
        thread_handles.push(thread_handle);
    }
    for thread_handle in thread_handles {
        thread_handle.join().unwrap();
    }
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
error[E0596]: cannot borrow data in a dereference of `RwLockReadGuard<'_, String>` as mutable
  --> src/main.rs:65:13
   |
65 |             guard.push_str("some characters");
   |             ^^^^^ cannot borrow as mutable
   |
   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `RwLockReadGuard<'_, String>`
                            </script></code></pre>
                </section>





                <section style="font-size: 2em">
                    <p>Louis Brandy's vexing parse</p>

                    <iframe width="1120" height="630" src="https://www.youtube.com/embed/lkgszkPnV8g?start=1750" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                </section>




                <section style="font-size: 1.3em">
                    Rust giveth and Rust taketh away
                    <div class="container">
                        <div class="col">
                            C++
                            <pre class="cpp"><code data-trim data-line-numbers="|6-11"><script type="text/template">
  shared_ptr<pair<mutex, string>> my_pair =
      make_shared<pair<mutex, string>>();
  vector<thread> thread_handles;
  for (int i = 0; i < 10; i++) {
    thread thread_handle([=] {
      string *smuggled_ptr;
      {
        lock_guard<mutex> guard(my_pair->first);
        smuggled_ptr = &my_pair->second;
      }
      *smuggled_ptr += "some characters";
    });
    thread_handles.push_back(move(thread_handle));
  }
  for (auto &thread_handle : thread_handles) {
    thread_handle.join();
  }
                            </script></code></pre>
                        </div>
                        <div class="col">
                            Rust
                            <pre class="rust"><code data-trim data-line-numbers="|7-10"><script type="text/template">
    let my_string: Arc<Mutex<String>> =
        Arc::new(Mutex::new(String::new()));
    let mut thread_handles = Vec::new();
    for _ in 0..10 {
        let arc_clone = my_string.clone();
        let thread_handle = thread::spawn(move || {
            let mut guard = arc_clone.lock().unwrap();
            let smuggled_ptr: &mut String = &mut *guard;
            drop(guard);
            smuggled_ptr.push_str("some characters");
        });
        thread_handles.push(thread_handle);
    }
    for thread_handle in thread_handles {
        thread_handle.join().unwrap();
    }
                            </script></code></pre>
                        </div>
                    </div>
                </section>
                <section style="font-size: 1.3em">
                            Rust
                            <pre class="rust"><code data-trim data-line-numbers="7-10"><script type="text/template">
    let my_string: Arc<Mutex<String>> =
        Arc::new(Mutex::new(String::new()));
    let mut thread_handles = Vec::new();
    for _ in 0..10 {
        let arc_clone = my_string.clone();
        let thread_handle = thread::spawn(move || {
            let mut guard = arc_clone.lock().unwrap();
            let smuggled_ptr: &mut String = &mut *guard;
            drop(guard);
            smuggled_ptr.push_str("some characters");
        });
        thread_handles.push(thread_handle);
    }
    for thread_handle in thread_handles {
        thread_handle.join().unwrap();
    }
                            </script></code></pre>
                            <pre><code data-trim><script type="text/template">
error[E0505]: cannot move out of `guard` because it is borrowed
  --> src/main.rs:84:18
   |
83 |             let smuggled_ptr: &mut String = &mut *guard;
   |                                                   ----- borrow of `guard` occurs here
84 |             drop(guard);
   |                  ^^^^^ move out of `guard` occurs here
85 |             smuggled_ptr.push_str("some characters");
   |             ------------ borrow later used here
                            </script></code></pre>
                </section>



                <section style="font-size: 2em">
                    <p>Fearless concurrency</p>
                    <p class="fragment">Fearless borrowing</p>
                    <p class="fragment">Fearless moves</p>
                    <p class="fragment">Fearless destructors</p>
                    <p class="fragment">Fearless systems programming</p>
                </section>


            </div>
        </div>

        <script src="dist/reveal.js"></script>
        <script src="plugin/notes/notes.js"></script>
        <script src="plugin/markdown/markdown.js"></script>
        <script src="plugin/highlight/highlight.js"></script>
        <script>
            // More info about initialization & config:
            // - https://revealjs.com/initialization/
            // - https://revealjs.com/config/
            Reveal.initialize({
                hash: true,

                width: "100%",
                height: "100%",
                margin: 0,

                transition: "none",

                // Learn about plugins: https://revealjs.com/plugins/
                plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
            });
        </script>
    </body>
</html>
